<script lang="ts">
	import { onMount, onDestroy } from 'svelte';
	import { goto } from '$app/navigation';

	import ErrorMessage from '$root/components/ErrorMessage.svelte';

	import { fetchTtsData, fetchEmpathyData } from '$root/api/talk';

	import {
		currentStatus,
		currentExpression,
		isTalking,
		status,
		expression,
		heard,
		say
	} from '$root/stores/bot';

	import SpeechRecog from '$root/components/talk/SpeechRecog.svelte';
	import MediaRec from '$root/components/talk/MediaRec.svelte';
	import { reloadApp } from '$root/utils/reloadApp';

	let error = false;
	let message: string;

	let hasMounted = false;

	let stream: any = null;
	let mediaRecorder: any = null;
	let audioSource: any;

	let command: string | null = null;
	let cmdResText: string;
	let cmdResEmotion: string;
	let continued = false;

	const DELAY_RELOAD = 1000 * 3;
	const WATCHDOG_LIMIT = 20;
	let watchdogTimer = 0;

	const setIdle = () => {
		$currentStatus = $status.idle;
	};

	const stopRunningApps = () => {
		if (mediaRecorder !== null) {
			console.debug(`${mediaRecorder} is being stopped`);
			mediaRecorder.stop();
		}
		if (stream !== null) {
			stream
				.getTracks() // get all tracks from the MediaStream
				.forEach((track: any) => {
					console.debug(`${track} is being stopped`);
					track.stop();
				}); // stop each of them
		}
	};

	const startMediaRecorder = async () => {
		stopRunningApps();

		try {
			stream = await navigator.mediaDevices.getUserMedia({ audio: true });
			mediaRecorder = new MediaRecorder(stream);
		} catch (err) {
			error = true;
			message = err as string;
			throw new Error(message);
		}
	};

	const handleSpeechOnstartIdle = async () => {
		console.log(`handleSpeechOnstartIdle | ${mediaRecorder.state}`);

		watchdogTimer = 0;

		if (audioSource && audioSource.removeEventListenr) {
			audioSource.removeEventListenr('ended', setIdle);
		}

		try {
			mediaRecorder.start();
		} catch (error) {
			await startMediaRecorder();
			console.error(`MediaRecorder restarted due to error: ${error}`);
		}
	};
	const handleSpeechOnstartElse = () => {
		console.log(`handleSpeechOnstartElse | ${mediaRecorder.state}`);

		if (
			($currentStatus === $status.thinking || $currentStatus === $status.talking) &&
			watchdogTimer < WATCHDOG_LIMIT
		) {
			console.debug(`watchdogTimer: ${watchdogTimer} times`);
			watchdogTimer++;
		} else if (watchdogTimer >= WATCHDOG_LIMIT) {
			reloadApp(window, DELAY_RELOAD);
		}
	};
	const handleSpeechOnresult = (event: any) => {
		console.log(`handleSpeechOnresult | ${mediaRecorder.state}`);
		const { results } = event.detail;
		$currentStatus = $status.listening;
		const text = Array.from(results)
			.map((result: any) => result[0])
			.map((result) => result.transcript)
			.join('');
		$heard = text;
	};
	const handleSpeechOnend = () => {
		console.log(`handleSpeechOnend | ${mediaRecorder.state}`);
		if ($currentStatus === $status.listening) $currentStatus = $status.thinking;
		if (mediaRecorder.state === 'recording') mediaRecorder.stop();
	};
	const handleRecordOnstop = async (event: any) => {
		console.log(`handleRecordOnstop | ${mediaRecorder.state}`);
		const audio = event.detail;
		const empathyReq = {
			audio,
			text: $heard,
			uid: 'temp-uid'
		};
		try {
			let empathyRes; // [TODO] connect to db

			if (!command) empathyRes = await fetchEmpathyData(empathyReq);
			const audioData: ArrayBuffer = await fetchTtsData(command ? cmdResText : empathyRes.text);

			const audioCtx = new AudioContext();

			audioCtx.decodeAudioData(audioData, (buffer) => {
				audioSource = audioCtx.createBufferSource();
				audioSource.addEventListener('ended', setIdle);
				audioSource.buffer = buffer;
				audioSource.connect(audioCtx.destination);
				audioSource.start(0);
			});

			//@ts-ignore
			$currentExpression = $expression[command ? cmdResEmotion : empathyRes.emotion];
			$say = command ? cmdResText : empathyRes.text;
			$currentStatus = $status.talking;
		} catch (error) {
			setIdle();
			console.error(`${error} (${$currentStatus})`);
		}
	};

	const onStatusChange = () => {
		$isTalking = false;

		switch ($currentStatus) {
			case $status.init: {
				$currentExpression = $expression.neutral;
				$currentStatus = $status.idle;
				$say = '연결 중...<br />잠시만 기다려주세요';
				break;
			}
			case $status.idle: {
				$currentExpression = $expression.neutral;

				if (command !== 'emergency' && command !== null) goto(command);
				if (!command) continued = false;
				command = null;

				break;
			}
			case $status.listening: {
				$currentExpression = $expression.listen;
				break;
			}
			case $status.thinking: {
				$currentExpression = $expression.think;
				break;
			}
			case $status.talking: {
				$isTalking = true;
				break;
			}
			default: {
				throw new Error('Invalid status change');
			}
		}
	};

	$: {
		$currentStatus;
		onStatusChange();
	}

	onMount(async () => {
		console.debug('Talk.svelte mounted');

		await startMediaRecorder();

		$currentStatus = $status.idle;
		$say = '안녕하세요';

		hasMounted = true;
	});

	onDestroy(async () => {
		await stopRunningApps();

		console.debug(`Talk.svelte destroyed`);
	});
</script>

{#if hasMounted}
	<SpeechRecog
		on:speech-onstart-idle={handleSpeechOnstartIdle}
		on:speech-onstart-else={handleSpeechOnstartElse}
		on:speech-onresult={handleSpeechOnresult}
		on:speech-onend={handleSpeechOnend}
	/>
	<MediaRec {mediaRecorder} on:record-onstop={handleRecordOnstop} />
	<ErrorMessage {error}>{message}</ErrorMessage>
{/if}

<!-- <div>
	-> {$say}
</div>

<div>
	-> {$heard}
</div>

<div>
	-> {$currentExpression}
</div>
<div>
	-> {$currentStatus}
</div> -->
